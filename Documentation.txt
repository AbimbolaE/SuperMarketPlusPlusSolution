# SuperMarketPlusPlusSolution
A solution to the SuperMarketPlusPlusExercise

## Step 1
   * Cloned remote repository and changed the remote url
   * Added Intellij files to .gitignore file

## Step 2
   * After viewing the old code, it does not seem scalable or maintainable. It has too much nested conditionals.
   * From the description of the business requirements, I can draw out five distinct types (Regular, Sulfaras, BackstagePasses, AgedBrie and OrganicBananas).
   * An ideal solution will be to leverage the features of Java and use a simple interface (ItemUpdater) which exposes a single method "update". This method should take an Item and update this Item with the appropriate strategy depending on what type of Item it is.
   * The reason I am choosing an interface over an abstract class and subtypes is simple. Although, the five types have some common features in terms of attributes, their behaviour in terms of being updated is very specific and there is no strong relationship between them (Some increase in quality over time, another decreases only, another increases and decreases). So an interface with a common method with different implementations is more suitable
   * I will start by creating the interface and a it's four implementations (Regular, Sulfaras, BackstagePasses, AgedBrie and OrganicBananas.
   * Also, the Item.class is in the default package which means it cannot be imported or used in other clases. I will move it to another package called "Model" so I can import and use it without modifying it's content. Otherwise, a wrapper class will be needed to use it which is not a solution leading to cleaner code.

## Step 3
   * I will be using a Factory class to seperate the instantiation of the object graph from the actual business logic. This factory will produce instances of the ItemUpdater interface given the name of an Item. I won't pass the actual Item in because that wouldn't be strictly following the Law of Demeter code-wise.
   * From this point onward, i will be using TDD to drive the design and creation of the classes.
   * I will also be adding the Hamcrest library (1.3) as a test dependency for assertions and verifications.
   * JUnit 4.11 comes with the hamcrest core as a transitive dependecy so, I will be excluding it from the JUnit dependency and import explicitly as a seperate dependency